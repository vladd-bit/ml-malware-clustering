import multiprocessing

import numpy
from androguard.core.bytecodes import apk
from androguard.misc import AnalyzeAPK
from pandas import DataFrame

from src.apkFeature import ApkFeature
from src.config import CPU_COUNT
from src.util import split_subsets, get_most_important_malware_families
from .fileReader import *
from itertools import islice
import itertools


class DataProcessor:

    def __init__(self, input_folder, output_folder, folder_lookup_name, csv_file_path, feature_vector_folder):
        self.archive_input_folder = input_folder
        self.data_output_folder = output_folder
        self.folder_lookup_name = folder_lookup_name
        self.labeled_apk_csv_file_path = csv_file_path
        self.feature_vector_folder_path = feature_vector_folder

        # variables used for storing actual data
        self.feature_vectors = None
        self.benign_feature_vectors = None

        # used for selecting only a specific subset of apk files
        self.feature_vectors_subset = None

        self.labeled_apk_csv = None
        self.labeled_apk_csv_subset = None

    """
        Reads the CSV file containing the APK files with their assigned labels.
    """

    def get_labeled_apk_csv(self, csv_file_path, only_loaded_apks=True, apk_list=None):

        # sha256_malware_families
        self.labeled_apk_csv = read_all_classified_data_csv(csv_file_path)
        self.labeled_apk_csv = [(item[0], item[1]) for item in self.labeled_apk_csv]

        if only_loaded_apks and self.feature_vectors:
            self.labeled_apk_csv = [(apk_name, value)
                                    for (apk_name, value) in self.labeled_apk_csv if
                                    apk_name in self.feature_vectors.keys()]

        self.labeled_apk_csv_subset = self.labeled_apk_csv

        if apk_list is not None:
            self.labeled_apk_csv_subset = [(apk_name, value)
                                           for (apk_name, value) in self.labeled_apk_csv if
                                           apk_name in apk_list]

    """
        Extracts the string feature vectors from the specified feature_vector folder or
        from the APK files depending on the settings specified

        Returns: full formatted feature vector that is ready for one-hot encoding.
    """

    def extract_data(self, get_existing_feature_vectors_only=False, drebin_apk_file_list=None,
                     include_all_samples=False):

        feature_vectors = {}

        Log.log_message(log_level="INFO",
                        log_message="started data extraction")

        if drebin_apk_file_list:
            self.get_labeled_apk_csv(csv_file_path=self.labeled_apk_csv_file_path,
                                     only_loaded_apks=not get_existing_feature_vectors_only,
                                     apk_list=drebin_apk_file_list)
        else:
            self.get_labeled_apk_csv(csv_file_path=self.labeled_apk_csv_file_path,
                                     only_loaded_apks=not get_existing_feature_vectors_only)

        self.categorise_applications_by_malware_type()

        if self.feature_vectors is not None and drebin_apk_file_list:
            self.feature_vectors_subset = {record_name: record_value
                                           for record_name, record_value in self.feature_vectors.items()
                                           if record_name in drebin_apk_file_list}

        if drebin_apk_file_list is None:

            drebin_apk_file_list = []

            if self.labeled_apk_csv_subset is not None and get_existing_feature_vectors_only:
                for item in self.labeled_apk_csv_subset.values():
                    drebin_apk_file_list.extend(item)

            else:
                drebin_apk_file_list = {}
                drebin_apk_file_list = read_all_zip_files_in_path(self.archive_input_folder,
                                                                  self.folder_lookup_name)

            malign_feature, benign_features = \
                read_files_in_folder(self.feature_vector_folder_path, drebin_apk_file_list,
                                     include_all_samples=include_all_samples)

            feature_vectors.update(malign_feature)

            if get_existing_feature_vectors_only:
                self.feature_vectors = self.format_features(feature_vectors)
                if include_all_samples:
                    self.benign_feature_vectors = dict(
                        itertools.islice(self.format_features(benign_features).items(), 5000))
            else:
                feature_vectors = {}

                split_apk_file_list = split_subsets(drebin_apk_file_list, CPU_COUNT)

                feature_vectors = self.extract_features_task([drebin_apk_file_list, True])

                self.feature_vectors = self.format_features(feature_vectors)

        if self.feature_vectors_subset is None:
            self.feature_vectors_subset = self.feature_vectors

        Log.log_message(log_level="INFO",
                        log_message="finished data extraction: processed " +
                                    str(len(self.feature_vectors_subset.keys())) + " MALICIOUS records")

        if include_all_samples:
            Log.log_message(log_level="INFO",
                            log_message="finished data extraction: processed " +
                                        str(len(self.benign_feature_vectors.keys())) + " BENIGN records")

    """
        Extracts feature from an APK file using Androguard
    """

    def extract_features_task(self, args):

        apk_info = {}
        apk_analysis = {}
        apk_features = {}

        drebin_apk_file_list = dict(args[0])
        analysis_mode = args[1]

        url_patterns = ['http://', 'https://', 'www\.', '\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\.|$)){4}\b']
        regex_patterns = []

        apks_to_ignore = []
        # apks_to_ignore = ['7a513817c9eac7f249c939252b48572824c9bb423ca31b3c5d84b242661d74bb',
        # '0899e04e972faded4f22138e6c1289f1095e9bfe5281d10c2866c7a5a9eec0b6',
        # '8994684817eb83cf360822238925c0025682a9ee804edbf40693a0320a444ed7',
        # '7bbd566f2f3abb78b3ffcc23ba4ad84e06a00f758d245c660c61b21814a850a5',
        # 'd53e4087beeee9323f86c7c65944cd10b8eb7bb78ca50de5a01e048b659aecb7',
        # 'ea153a9dc50f5f9dbaaa29d764b54a819e6b8c0917b000f1c78a32be77f2f804',
        # 'b7c760781b8d3cfbf7b6657b8ec5f232405038ff399f78f8d05c391de54401b9',
        #  '6337b2ed626ae2ff6f9bd7e09a90abf78cc61c301d5dd18fa936a893766c819e']

        for url_pattern in url_patterns:
            regex_patterns.append(re.compile('^' + url_pattern + '[a-zA-Z]+'))

        for drebin_apk_name, drebin_apk_path in drebin_apk_file_list.items():
            if drebin_apk_name not in apks_to_ignore:

                try:
                    apk_features[drebin_apk_name] = []

                    url_features = []
                    calls = []
                    api_calls = []

                    if analysis_mode is False:
                        apk_info[drebin_apk_name] = apk.APK(drebin_apk_path, raw=False, skip_analysis=False,
                                                            testzip=False)
                    else:

                        apk_object, dalvik_vmf, analysis_obj = AnalyzeAPK(drebin_apk_path)
                        apk_info[drebin_apk_name] = apk_object

                        strings = analysis_obj.get_strings_analysis()
                        for s in strings.keys():
                            if s != '':
                                for url_pattern in regex_patterns:
                                    if re.search(url_pattern, s):
                                        if s not in url_features:
                                            url_features.append(s)

                        for c in analysis_obj.get_classes():
                            for meth in c.get_methods():
                                for _, call, _ in meth.get_xref_to():
                                    calls.append(str(call.class_name) + "->" + str(call.name))
                                for _, call, _ in meth.get_xref_from():
                                    api_calls.append(str(call.class_name) + "->" + str(call.name))

                    features_dict = {
                        'permission': apk_info[drebin_apk_name].get_permissions(),
                        'activity': apk_info[drebin_apk_name].get_activities(),
                        'real_permission': apk_info[drebin_apk_name].get_requested_permissions(),
                        'feature': apk_object.get_features(),
                        'service_receiver': apk_info[drebin_apk_name].get_services() + apk_info[
                            drebin_apk_name].get_receivers(),
                        'provider': apk_info[drebin_apk_name].get_providers(),
                        'url': url_features,
                    }

                    possible_feature_names = ['permission', 'activity', 'provider', 'feature', 'url', 'network',
                                              'feature', 'call', 'api_call'
                                                                 'real_permission', 'service_receiver']

                    intents = []

                    for item_type in possible_feature_names:
                        for key in features_dict.keys():
                            for val in features_dict[key]:
                                intent_filters = apk_info[drebin_apk_name].get_intent_filters(item_type, val)

                                if len(intent_filters) > 0:
                                    for intent in intent_filters.values():
                                        if intent not in intents:
                                            intents.append(intent)

                    features_dict['intent'] = intents
                    features_dict['call'] = calls
                    features_dict['api_call'] = api_calls

                    apk_features[drebin_apk_name].append(features_dict)



                except OSError as exception:
                    Log.log_message(log_level="ERROR",
                                    log_message='cannot process file:' + drebin_apk_name + ' path:' + drebin_apk_path,
                                    exception=exception)

        return apk_features

    def format_features(self, unformatted_feature_vectors):

        segmented_features = {}

        Log.log_message(log_level="INFO",
                        log_message="started feature formatting")

        segmented_features.update(self.segment_features_task(unformatted_feature_vectors))

        Log.log_message(log_level="INFO",
                        log_message="feature formatting completed: processed " +
                                    str(len(segmented_features)) + " records")

        return segmented_features

    """
        Input: raw feature vector string
        Formats features according to the feature string and puts them in a dictionary recording their presence,
           e.g, dict[APK sample name] = {'activity::a' : True, 'url:abcd', 'call::func1->func2' : True}

        Returns: processed dictionary with all samples and their features in list format.
    """

    def segment_features_task(self, feature_vector):

        processed_features = {}

        overall_feature_count = {}

        # keeps feature categories in data set
        ignore_feature_tags = [
            # 'call',
            # 'api_call',
            # 'intent',
            # 'feature',
            # 'service_receiver',
            # 'activity',
            # 'provider',
            #  'network',
            #   'url',
            #  'permission',
            #  'real_permission'
        ]

        tag_count = {}

        for apk_name, features in dict(feature_vector).items():

            tmp_grouped_features = {}

            found_tags = []

            for line in features:
                if type(line) is dict:
                    for k in line.keys():
                        for feature_str in line[k]:
                            line_ = str(k) + '::' + str(feature_str)

                            split_line = [str(k), str(feature_str)]

                            if line_ not in overall_feature_count.keys():
                                overall_feature_count[line_] = 1
                            else:
                                overall_feature_count[line_] = overall_feature_count[line_] + 1
                                if len(split_line) >= 1:
                                    if split_line[0] not in found_tags:
                                        found_tags.append(split_line[0])
                                    if split_line[0] not in list(ignore_feature_tags):
                                        tmp_grouped_features[line_] = True
                        for tag in found_tags:
                            if tag not in tag_count.keys():
                                tag_count[tag] = 1
                            else:
                                tag_count[tag] = tag_count[tag] + 1
                else:
                    split_line = line.split("::")

                    if line not in overall_feature_count.keys():
                        overall_feature_count[line] = 1
                    else:
                        overall_feature_count[line] = overall_feature_count[line] + 1

                    if len(split_line) >= 1:
                        if split_line[0] not in found_tags:
                            found_tags.append(split_line[0])
                        if split_line[0].strip() not in list(ignore_feature_tags):
                            tmp_grouped_features[line] = True

            for tag in found_tags:
                if tag not in tag_count.keys():
                    tag_count[tag] = 1
                else:
                    tag_count[tag] = tag_count[tag] + 1

            processed_features[apk_name] = tmp_grouped_features

        tag_by_malware_family = {}

        test = get_most_important_malware_families(self.labeled_apk_csv, sample_count_threshold=1)

        for malware_family, apk_list in self.labeled_apk_csv.items():

            overall_feature_count = {}

            tag_count = {}

            found_tags = []

            if malware_family in list(test['threshold_samples'].keys()):
                for apk_name, features in dict(feature_vector).items():
                    if apk_name in list(apk_list):
                        for line in features:

                            if type(line) is dict:

                                for k in line.keys():
                                    for feature_str in line[k]:
                                        line_ = str(k) + '::' + str(feature_str)

                                        split_line = [k, feature_str]

                                        if line_ not in overall_feature_count.keys():
                                            overall_feature_count[line_] = 1
                                        else:
                                            overall_feature_count[line_] = overall_feature_count[line_] + 1
                                            if len(split_line) >= 1:
                                                found_tags.append(split_line[0])
                                            if split_line[0] not in tag_count.keys():
                                                tag_count[split_line[0]] = 1
                                            else:
                                                tag_count[split_line[0]] = tag_count[split_line[0]] + 1
                                        tag_by_malware_family[malware_family] = tag_count
                            else:
                                split_line = line.split("::")
                                if line not in overall_feature_count.keys():
                                    overall_feature_count[line] = 1
                                else:
                                    overall_feature_count[line] = overall_feature_count[line] + 1

                                if len(split_line) >= 1:
                                    if split_line[0] not in found_tags:
                                        found_tags.append(split_line[0])
                                    if split_line[0] not in tag_count.keys():
                                        tag_count[split_line[0]] = 1
                                    else:
                                        tag_count[split_line[0]] = tag_count[split_line[0]] + 1

                                tag_by_malware_family[malware_family] = tag_count

        tee = DataFrame.from_dict(tag_by_malware_family)

        for i in tee.head():
            if i in list(test['threshold_samples'].keys()):
                tee[i] = tee[i].fillna(0).astype(int)

        return processed_features

    # reorganizing the dictionary to have the malware family as key and the apks as values
    def categorise_applications_by_malware_type(self):

        malware_families_apks = {}

        subset_apks = {}

        for (key, value) in self.labeled_apk_csv:

            if value not in malware_families_apks:
                malware_families_apks[value] = []

            malware_families_apks[value].append(key)

            if (key, value) in self.labeled_apk_csv_subset:
                if value not in subset_apks.keys():
                    subset_apks[value] = []
                subset_apks[value].append(key)

        self.labeled_apk_csv = malware_families_apks
        self.labeled_apk_csv_subset = subset_apks
